#!/usr/bin/env node

/**
 * Verifier Contract Generator
 * 
 * Generates Solidity verifier contract from zkey
 * 
 * Usage: node generate-verifier.js
 */

const path = require('path');
const fs = require('fs');
const { exec } = require('child_process');
const util = require('util');

const execPromise = util.promisify(exec);

// Paths
const CIRCUIT_DIR = path.join(__dirname, '..');
const KEYS_DIR = path.join(CIRCUIT_DIR, 'keys');
const CONTRACTS_DIR = path.join(__dirname, '..', '..', 'contracts');
const CIRCUIT_NAME = 'DeFiCreditScore';

const ZKEY_FILE = path.join(KEYS_DIR, `${CIRCUIT_NAME}_final.zkey`);
const VERIFIER_FILE = path.join(CONTRACTS_DIR, 'Verifier.sol');

// Colors
const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    red: '\x1b[31m',
    cyan: '\x1b[36m'
};

function log(message, color = colors.reset) {
    console.log(`${color}${message}${colors.reset}`);
}

function logStep(step, message) {
    log(`\n[STEP ${step}] ${message}`, colors.cyan + colors.bright);
}

function logSuccess(message) {
    log(`✓ ${message}`, colors.green);
}

function logError(message) {
    log(`✗ ${message}`, colors.red);
}

function logInfo(message) {
    log(`ℹ ${message}`, colors.cyan);
}

async function ensureDirectory(dir) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        logSuccess(`Created directory: ${dir}`);
    }
}

async function checkZKeyExists() {
    logStep('1', 'Checking proving key');
    
    if (!fs.existsSync(ZKEY_FILE)) {
        logError('Proving key not found. Run trusted setup first:');
        console.log('  node scripts/trusted-setup.js');
        return false;
    }
    
    const stats = fs.statSync(ZKEY_FILE);
    logSuccess(`Proving key found: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);
    return true;
}

async function generateVerifier() {
    logStep('2', 'Generating Solidity verifier contract');
    
    try {
        logInfo('This may take a minute...');
        
        const cmd = `npx snarkjs zkey export solidityverifier ${ZKEY_FILE} ${VERIFIER_FILE}`;
        const { stdout, stderr } = await execPromise(cmd);
        
        if (stderr) {
            console.log(stderr);
        }
        
        logSuccess(`Verifier contract generated: ${VERIFIER_FILE}`);
        
        const stats = fs.statSync(VERIFIER_FILE);
        logInfo(`Contract size: ${(stats.size / 1024).toFixed(2)} KB`);
        
        return true;
    } catch (error) {
        logError('Verifier generation failed');
        console.error(error.message);
        return false;
    }
}

async function optimizeVerifier() {
    logStep('3', 'Optimizing verifier contract');
    
    try {
        let content = fs.readFileSync(VERIFIER_FILE, 'utf8');
        
        // Add SPDX license
        if (!content.includes('SPDX-License-Identifier')) {
            content = '// SPDX-License-Identifier: MIT\n' + content;
        }
        
        // Update pragma to latest
        content = content.replace(/pragma solidity \^[\d.]+;/, 'pragma solidity ^0.8.20;');
        
        // Rename contract to be more descriptive
        content = content.replace(/contract Verifier/, 'contract DeFiScoreVerifier');
        
        // Add documentation
        const docs = `
/**
 * @title DeFi Credit Score Verifier
 * @notice Groth16 verifier for DeFi credit score ZK proofs
 * @dev Auto-generated by snarkjs. Do not modify manually.
 * 
 * Circuit: ${CIRCUIT_NAME}
 * Version: 1.0.0
 * Generated: ${new Date().toISOString()}
 * 
 * Public Inputs (11):
 *   [0] userAddress - Ethereum address (as field element)
 *   [1] scoreTotal - Total credit score (scaled x1000)
 *   [2] scoreRepayment - Repayment component score
 *   [3] scoreCapital - Capital management score
 *   [4] scoreLongevity - Wallet longevity score
 *   [5] scoreActivity - Activity patterns score
 *   [6] scoreProtocol - Protocol diversity score
 *   [7] threshold - Minimum score threshold
 *   [8] timestamp - Proof generation timestamp
 *   [9] nullifier - Replay prevention hash
 *   [10] versionId - Circuit version identifier
 */
`;
        
        content = content.replace(/contract DeFiScoreVerifier/, docs + 'contract DeFiScoreVerifier');
        
        fs.writeFileSync(VERIFIER_FILE, content);
        
        logSuccess('Verifier contract optimized');
        return true;
    } catch (error) {
        logError('Optimization failed');
        console.error(error.message);
        return false;
    }
}

async function analyzeVerifier() {
    logStep('4', 'Analyzing verifier contract');
    
    try {
        const content = fs.readFileSync(VERIFIER_FILE, 'utf8');
        
        // Count lines
        const lines = content.split('\n').length;
        logInfo(`Lines of code: ${lines}`);
        
        // Estimate gas (rough approximation)
        const estimatedGas = 250000 + (lines * 100);
        logInfo(`Estimated verification gas: ~${estimatedGas.toLocaleString()}`);
        
        // Check for view function
        if (content.includes('function verifyProof')) {
            logSuccess('verifyProof function found');
        }
        
        return true;
    } catch (error) {
        logError('Analysis failed');
        console.error(error.message);
        return false;
    }
}

async function generateDeploymentScript() {
    logStep('5', 'Generating deployment script');
    
    const deployScript = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Verifier.sol";

/**
 * @title DeFi Score Verifier Deployment
 * @notice Helper contract for deploying the verifier
 */
contract DeployVerifier {
    DeFiScoreVerifier public verifier;
    
    event VerifierDeployed(address indexed verifier, uint256 timestamp);
    
    constructor() {
        verifier = new DeFiScoreVerifier();
        emit VerifierDeployed(address(verifier), block.timestamp);
    }
    
    function getVerifierAddress() external view returns (address) {
        return address(verifier);
    }
}
`;
    
    const deployPath = path.join(CONTRACTS_DIR, 'DeployVerifier.sol');
    fs.writeFileSync(deployPath, deployScript);
    
    logSuccess(`Deployment script generated: ${deployPath}`);
    return true;
}

async function generateReport() {
    logStep('6', 'Generating report');
    
    const content = fs.readFileSync(VERIFIER_FILE, 'utf8');
    const lines = content.split('\n').length;
    const size = fs.statSync(VERIFIER_FILE).size;
    
    const report = {
        timestamp: new Date().toISOString(),
        circuit: CIRCUIT_NAME,
        version: '1.0.0',
        verifier: {
            contract_name: 'DeFiScoreVerifier',
            file: path.basename(VERIFIER_FILE),
            lines_of_code: lines,
            size_bytes: size,
            size_kb: (size / 1024).toFixed(2),
            estimated_gas: 250000 + (lines * 100)
        },
        public_inputs: {
            count: 11,
            inputs: [
                'userAddress',
                'scoreTotal',
                'scoreRepayment',
                'scoreCapital',
                'scoreLongevity',
                'scoreActivity',
                'scoreProtocol',
                'threshold',
                'timestamp',
                'nullifier',
                'versionId'
            ]
        },
        deployment: {
            solidity_version: '^0.8.20',
            optimization_enabled: true,
            runs: 200
        }
    };
    
    const reportPath = path.join(CONTRACTS_DIR, 'verifier-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    logSuccess(`Report saved: ${reportPath}`);
    
    // Print summary
    console.log('\n' + '='.repeat(70));
    log('VERIFIER CONTRACT SUMMARY', colors.bright + colors.green);
    console.log('='.repeat(70));
    console.log(`Circuit:           ${report.circuit} v${report.version}`);
    console.log(`Timestamp:         ${report.timestamp}`);
    console.log(`\nContract Details:`);
    console.log(`  Name:            ${report.verifier.contract_name}`);
    console.log(`  File:            ${report.verifier.file}`);
    console.log(`  Lines of Code:   ${report.verifier.lines_of_code}`);
    console.log(`  Size:            ${report.verifier.size_kb} KB`);
    console.log(`  Estimated Gas:   ~${report.verifier.estimated_gas.toLocaleString()}`);
    console.log(`\nPublic Inputs:     ${report.public_inputs.count}`);
    report.public_inputs.inputs.forEach((input, i) => {
        console.log(`  [${i}] ${input}`);
    });
    console.log(`\nDeployment:`);
    console.log(`  Solidity:        ${report.deployment.solidity_version}`);
    console.log(`  Optimization:    ${report.deployment.optimization_enabled ? 'Enabled' : 'Disabled'}`);
    console.log(`  Runs:            ${report.deployment.runs}`);
    console.log('='.repeat(70) + '\n');
}

async function main() {
    log('\n' + '='.repeat(70), colors.bright);
    log('DeFi Credit Score - Verifier Contract Generator', colors.bright + colors.cyan);
    log('='.repeat(70) + '\n', colors.bright);
    
    // Check prerequisites
    const zkeyExists = await checkZKeyExists();
    if (!zkeyExists) {
        process.exit(1);
    }
    
    // Ensure contracts directory exists
    await ensureDirectory(CONTRACTS_DIR);
    
    // Generate verifier
    const generated = await generateVerifier();
    if (!generated) {
        process.exit(1);
    }
    
    // Optimize verifier
    const optimized = await optimizeVerifier();
    if (!optimized) {
        process.exit(1);
    }
    
    // Analyze verifier
    await analyzeVerifier();
    
    // Generate deployment script
    await generateDeploymentScript();
    
    // Generate report
    await generateReport();
    
    log('\n✓ Verifier contract generation complete!', colors.green + colors.bright);
    log('\nNext steps:', colors.cyan);
    console.log('  1. Review contract: contracts/Verifier.sol');
    console.log('  2. Compile with Hardhat/Foundry');
    console.log('  3. Deploy to testnet');
    console.log('  4. Integrate with DeFiScoreRegistry\n');
}

// Run
main().catch(error => {
    logError('Fatal error:');
    console.error(error);
    process.exit(1);
});
